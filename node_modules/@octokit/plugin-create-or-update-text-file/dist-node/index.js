'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var requestError = require('@octokit/request-error');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

/* istanbul ignore file */
// universal implementation of nodeUtf8ToBase64/nodeBase64ToUtf8 methods for browsers, Node, and Deno.
//
// - good docs on base64
//   https://developer.mozilla.org/en-US/docs/Glossary/Base64
// - great insights on why escape/unescape is needed
//   https://stackoverflow.com/questions/30631927/converting-to-base64-in-javascript-without-deprecated-escape-call
//
// Known problem with atob/btoa:
// https://github.com/octokit/plugin-create-or-update-text-file.js/issues/15
const isNode = globalThis.process && globalThis.process.release && globalThis.process.release.name;

function nodeUtf8ToBase64(data) {
  return Buffer.from(data, "utf-8").toString("base64");
}

function nodeBase64ToUtf8(data) {
  return Buffer.from(data, "base64").toString("utf-8");
} // browserUtf8ToBase64 & browserBase64ToUtf8
// (c) Brandon Rylow - CC BY-SA 4.0
// https://stackoverflow.com/a/30106551/206879


function browserUtf8ToBase64(data) {
  // first we use encodeURIComponent to get percent-encoded UTF-8,
  // then we convert the percent encodings into raw bytes which
  // can be fed into btoa.
  return btoa(encodeURIComponent(data).replace(/%([0-9A-F]{2})/g, function toSolidBytes(_match, p1) {
    // @ts-expect-error - we know what we are doing here
    return String.fromCharCode("0x" + p1);
  }));
}

function browserBase64ToUtf8(data) {
  // Going backwards: from bytestream, to percent-encoding, to original string.
  return decodeURIComponent(atob(data).split("").map(function (c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}

const utf8ToBase64 = isNode ? nodeUtf8ToBase64 : browserUtf8ToBase64;
const base64ToUtf8 = isNode ? nodeBase64ToUtf8 : browserBase64ToUtf8;

/**
 * Normalizes the retrival of a repository file content.
 *
 * The "Get repository content" API can respond in 4 different ways depending
 * on what exists at the given path
 *
 * - An array of folder item objects
 * - An object with type = symlink
 * - An object with type = submodule
 * - An object with type = file
 *
 * We are only interested in the last type, and throw errors in all other cases
 *
 * @see https://docs.github.com/en/rest/reference/repos#get-repository-content
 * @param octokit Octokit instance
 * @param options
 */

async function getFileContents(octokit, options) {
  const route = "GET /repos/{owner}/{repo}/contents/{path}";
  const requestOptions = octokit.request.endpoint(route, options);
  const {
    data
  } = await octokit.request(route, options).catch(error => {
    /* istanbul ignore if */
    if (error.status !== 404) throw error;
    return {
      data: {
        content: null,
        type: "",
        sha: ""
      }
    };
  });

  if (Array.isArray(data)) {
    throw new requestError.RequestError(`[@octokit/plugin-create-or-update-text-file] ${requestOptions.url} is a directory`, 403, {
      request: requestOptions
    });
  }

  if (!("sha" in data && "content" in data)) {
    throw new requestError.RequestError(`[@octokit/plugin-create-or-update-text-file] ${requestOptions.url} is not a file, but a ${data.type}`, 403, {
      request: requestOptions
    });
  }

  if (data.content === null) {
    return {
      content: null
    };
  }

  try {
    return {
      content: base64ToUtf8(data.content),
      sha: data.sha
    };
  } catch (error) {
    /* istanbul ignore next */
    if (error.message !== "URI malformed") throw error;
    /* istanbul ignore next error is only thrown in browsers, not node. */

    throw new requestError.RequestError(`[@octokit/plugin-create-or-update-text-file] ${requestOptions.url} is a binary file, only text files are supported`, 403, {
      request: requestOptions
    });
  }
}

const _excluded = ["content", "message", "committer", "author"];
/**
 *
 * @param octokit Octokit instance
 * @param options
 */

async function composeCreateOrUpdateTextFile(octokit, options) {
  const {
    content: contentOrFn,
    message,
    committer,
    author
  } = options,
        getOptions = _objectWithoutProperties(options, _excluded);

  const currentFile = await getFileContents(octokit, getOptions); // normalize content

  const content = typeof contentOrFn === "function" ? await contentOrFn({
    exists: currentFile.content !== null,
    content: currentFile.content
  }) : contentOrFn; // do nothing if there are no changes

  if (content === currentFile.content) {
    return {
      updated: false,
      deleted: false,
      data: {},
      headers: {}
    };
  } // delete file if it exists and new content is `null`


  if (currentFile.sha && content === null) {
    // https://docs.github.com/en/rest/reference/repos#delete-a-file
    const response = await octokit.request("DELETE /repos/{owner}/{repo}/contents/{path}", _objectSpread2(_objectSpread2({}, getOptions), {}, {
      message,
      sha: currentFile.sha
    }));
    return _objectSpread2(_objectSpread2({}, response), {}, {
      updated: true,
      deleted: true
    });
  } // update file to new content
  // https://docs.github.com/en/rest/reference/repos#create-or-update-file-contents


  const response = await octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", _objectSpread2(_objectSpread2(_objectSpread2({}, getOptions), {}, {
    message
  }, currentFile), {}, {
    content: utf8ToBase64(content)
  }));
  return _objectSpread2(_objectSpread2({}, response), {}, {
    updated: true,
    deleted: false,
    content: content
  });
}

const VERSION = "1.0.3";

/**
 * @param octokit Octokit instance
 */

function createOrUpdateTextFile(octokit) {
  return {
    createOrUpdateTextFile(options) {
      return composeCreateOrUpdateTextFile(octokit, options);
    }

  };
}
createOrUpdateTextFile.VERSION = VERSION;

exports.composeCreateOrUpdateTextFile = composeCreateOrUpdateTextFile;
exports.createOrUpdateTextFile = createOrUpdateTextFile;
//# sourceMappingURL=index.js.map
